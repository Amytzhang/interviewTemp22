// 时间复杂度n^2
//设置未排序最小值下标，外层循环表示趟数，内层循环比较最小值和其它数据大小，比最小值小的更改记录下标，直至循环完毕，交换最小值。
/**
 * 适应场景：
 * 选择排序的时间复杂度为O(n²)，空间复杂度为O(1)，与冒泡排序复杂度相同，
 * 但由于每次选出待排序数据中的最小值（增序）或最大值（降序）插入到当前的有序队列中，
 * 相对于冒泡排序减少了交换的次数。当数据量不大，且对稳定性没有要求的时候，适用于选择排序
 */
/**
 * 思路：
1）假设未排序序列的第一个是最小值，记下该元素的位置，从前往后比较
2）若某个元素比该元素小，覆盖最小值的位置
3）重复第二个步骤，直到找到未排序的末尾
4）将未排序元素的第一个元素和最大元素交换位置
5）重复前面几个步骤，直到所有元素都已经排序。 
 */
function selectSorts(arr) {
    let length = arr.length;
    let minIndex;
    for (let i = 0; i < length - 1; i++) {
        //初始化minIndex为当前区间第一个元素
        minIndex = i;
        //i,j分别定义当前区域的上下界，i是左边界,j是右边界
        for (let j = i; j < length; j++) {
            //若j处的数据项比当前最小值还要小，则更新最小值索引为j
            if (arr[j] < arr[minIndex]) {
                minIndex = j
            }
        }
        //如果minIndex对应元素不是目前的头部元素，则交换两者
        if (minIndex != i) {
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
        }

    }
    return arr
}

console.log(selectSorts([3, 5, 6, 4, 2, 1, 7, 8]))